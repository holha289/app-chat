import { useEffect, useRef, useState } from "react";
import { getSocket } from "@app/core/socketIo";
import InCallManager from "react-native-incall-manager";
import {
  mediaDevices,
  RTCPeerConnection,
  RTCIceCandidate,
  RTCSessionDescription,
  MediaStream,
} from "react-native-webrtc";
import { requestMediaPermissions } from "@app/core/permissions";

const pcConfig: RTCConfiguration = {
  iceServers: [
    { urls: ["stun:stun.l.google.com:19302"] },
    { urls: ["stun:stun1.l.google.com:19302"] },
    { urls: ["stun:stun2.l.google.com:19302"] },
    // Th√™m TURN server backup (n·∫øu c√≥)
    {
      urls: "turn:your-domain.com:3478",
      username: "webrtc",
      credential: "superSecretPassword",
    },
  ],
  iceCandidatePoolSize: 10,
  // Th√™m c·∫•u h√¨nh ƒë·ªÉ x·ª≠ l√Ω m·∫°ng y·∫øu
  iceTransportPolicy: 'all',
  bundlePolicy: 'max-bundle',
  rtcpMuxPolicy: 'require',
};

// H√†ng ƒë·ª£i ICE khi remoteDescription ch∆∞a c√≥
const pendingCandidates = new Map<string, RTCIceCandidateInit[]>();

export const useWebRTC = (isVideoCall: boolean) => {
  const [localStream, setLocalStream] = useState<MediaStream | null>(null);
  const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);
  const [isMuted, setIsMuted] = useState(false);
  const [isSpeakerOn, setIsSpeakerOn] = useState(true);
  const [isVideoOff, setIsVideoOff] = useState(false);

  const peers = useRef<Map<string, RTCPeerConnection>>(new Map());
  const reconnectAttempts = useRef<Map<string, number>>(new Map());
  const reconnectTimers = useRef<Map<string, NodeJS.Timeout>>(new Map());
  const socketIo = getSocket();

  // Kh·ªüi t·∫°o local stream
  const initStream = async () => {
    try {
      const ok = await requestMediaPermissions();
      if (!ok) {
        console.error("‚ùå User t·ª´ ch·ªëi quy·ªÅn Camera/Micro");
        return;
      }
      
      const stream = await mediaDevices.getUserMedia({
        audio: true,
        video: isVideoCall,
      });
      
      setLocalStream(stream);
      
      // C√†i ƒë·∫∑t InCallManager cho ph√π h·ª£p v·ªõi lo·∫°i cu·ªôc g·ªçi
      InCallManager.start({ media: isVideoCall ? "video" : "audio" });

      return stream;
    } catch (err) {
      console.error("‚ùå Error init media:", err);
      return null;
    }
  };

  const createPeerConnection = (roomId: string, peerId: string, forceStream?: MediaStream) => {
    // S·ª≠ d·ª•ng stream ƒë∆∞·ª£c truy·ªÅn v√†o n·∫øu c√≥, n·∫øu kh√¥ng th√¨ d√πng localStream t·ª´ state
    const streamToUse = forceStream || localStream;
    
    // Ki·ªÉm tra xem ƒë√£ c√≥ stream ch∆∞a
    if (!streamToUse) {
      console.error("‚ùå Cannot create peer connection: No stream available");
      throw new Error("No local stream available when creating peer connection");
    }
    
    const pc = new RTCPeerConnection(pcConfig);
    peers.current.set(peerId, pc);

    // Th√™m local track
    streamToUse.getTracks().forEach((track) => {
      pc.addTrack(track, streamToUse);
    });

    // ICE Candidate
    pc.onicecandidate = (event) => {
      if (event.candidate) {
        socketIo?.emit("call:signal", {
          peerId: peerId,
          roomId,
          candidate: event.candidate,
        });
      }
    };

    // Enhanced connection state monitoring v·ªõi auto recovery
    pc.oniceconnectionstatechange = () => {
      const attempts = reconnectAttempts.current.get(peerId) || 0;
      
      switch (pc.iceConnectionState) {
        case 'connected':
          console.log(`‚úÖ WebRTC connected for peer ${peerId}`);
          // Reset reconnect attempts khi k·∫øt n·ªëi th√†nh c√¥ng
          reconnectAttempts.current.set(peerId, 0);
          // Clear timer n·∫øu c√≥
          const timer = reconnectTimers.current.get(peerId);
          if (timer) {
            clearTimeout(timer);
            reconnectTimers.current.delete(peerId);
          }
          break;
          
        case 'disconnected':
          console.log(`‚ö†Ô∏è WebRTC disconnected for peer ${peerId} - will attempt reconnection`);
          // ƒê·ª£i m·ªôt ch√∫t tr∆∞·ªõc khi reconnect (c√≥ th·ªÉ l√† disconnect t·∫°m th·ªùi)
          const disconnectTimer = setTimeout(() => {
            if (pc.iceConnectionState === 'disconnected') {
              attemptReconnection(peerId, roomId);
            }
          }, 3000); // ƒê·ª£i 3 gi√¢y
          reconnectTimers.current.set(peerId, disconnectTimer);
          break;
          
        case 'failed':
          console.error(`‚ùå WebRTC connection failed for peer ${peerId} (attempt ${attempts + 1})`);
          attemptReconnection(peerId, roomId);
          break;
          
        case 'closed':
          console.log(`üî¥ WebRTC connection closed for peer ${peerId}`);
          // Cleanup cho peer n√†y
          cleanupPeer(peerId);
          break;
      }
    };

    // Monitoring connection state
    pc.onconnectionstatechange = () => {
      console.log(`üîó Connection State for ${peerId}:`, pc.connectionState);
      
      if (pc.connectionState === 'failed') {
        console.error(`‚ùå Peer connection failed for ${peerId}`);
        attemptReconnection(peerId, roomId);
      }
    };

    // Monitoring ICE gathering state
    pc.onicegatheringstatechange = () => {
      console.log(`üßä ICE Gathering State for ${peerId}:`, pc.iceGatheringState);
    };

    // Remote track
    pc.ontrack = (event) => {
      if (event.streams && event.streams[0]) {
        const stream = event.streams[0];
        
        // Ki·ªÉm tra tracks c√≥ enabled v√† readyState l√† 'live'
        const liveTracks = stream.getTracks().filter(track => 
          track.enabled && track.readyState === 'live'
        );
        
        if (liveTracks.length > 0) {
          setRemoteStream(stream as any);
        } else {
          // ƒê·ª£i tracks s·∫µn s√†ng v·ªõi timeout
          const checkTracksReady = () => {
            const readyTracks = stream.getTracks().filter(track => 
              track.enabled && track.readyState === 'live'
            );
            
            if (readyTracks.length > 0) {
              setRemoteStream(stream as any);
            } else {
              setTimeout(checkTracksReady, 100);
            }
          };
          
          setTimeout(checkTracksReady, 100);
        }
      }
    };

    return pc;
  };

  // Caller: t·∫°o offer v√† g·ª≠i
  const caller = async (roomId: string, calleeId: string) => {
    const stream = await initStream();
    if (!stream) {
      console.error("‚ùå Failed to initialize local stream for caller");
      return;
    }
    
    try {
      // Truy·ªÅn tr·ª±c ti·∫øp stream v√†o createPeerConnection ƒë·ªÉ tr√°nh v·∫•n ƒë·ªÅ v·ªõi state
      const pc = createPeerConnection(roomId, calleeId, stream);
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      socketIo?.emit("call:signal", {
        peerId: calleeId,
        roomId,
        offer,
      });
    } catch (error) {
      console.error("‚ùå Error creating/sending offer:", error);
    }
  };

  // Callee: ch·∫•p nh·∫≠n l·ªùi m·ªùi v√† chu·∫©n b·ªã nh·∫≠n offer
  const callee = async (roomId: string, callerId: string) => {
    // ƒê·∫£m b·∫£o kh·ªüi t·∫°o localStream th√†nh c√¥ng tr∆∞·ªõc khi t·∫°o peer connection
    const stream = await initStream();
    if (!stream) {
      console.error("‚ùå Failed to initialize local stream for callee");
      return;
    }
    // Truy·ªÅn tr·ª±c ti·∫øp stream v√†o createPeerConnection ƒë·ªÉ tr√°nh v·∫•n ƒë·ªÅ v·ªõi state
    createPeerConnection(roomId, callerId, stream);
    // Offer s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω trong listenCall
  };

  // Function ƒë·ªÉ th·ª≠ reconnect
  const attemptReconnection = async (peerId: string, roomId: string) => {
    const maxAttempts = 3;
    const currentAttempts = reconnectAttempts.current.get(peerId) || 0;
    
    if (currentAttempts >= maxAttempts) {
      console.error(`‚ùå Max reconnection attempts (${maxAttempts}) reached for peer ${peerId}`);
      // C√≥ th·ªÉ th√¥ng b√°o cho user ho·∫∑c ƒë√≥ng cu·ªôc g·ªçi
      return;
    }

    console.log(`üîÑ Attempting reconnection ${currentAttempts + 1}/${maxAttempts} for peer ${peerId}`);
    reconnectAttempts.current.set(peerId, currentAttempts + 1);

    try {
      // ƒê·ª£i m·ªôt ch√∫t tr∆∞·ªõc khi th·ª≠ l·∫°i (exponential backoff)
      const delay = Math.pow(2, currentAttempts) * 1000; // 1s, 2s, 4s
      await new Promise(resolve => setTimeout(resolve, delay));

      const pc = peers.current.get(peerId);
      if (!pc || !localStream) {
        console.error(`‚ùå Cannot reconnect: missing peer connection or local stream for ${peerId}`);
        return;
      }

      // Th·ª≠ restart ICE tr∆∞·ªõc
      console.log(`üßä Restarting ICE for peer ${peerId}`);
      pc.restartIce();

      // T·∫°o offer m·ªõi v·ªõi iceRestart
      const offer = await pc.createOffer({ iceRestart: true });
      await pc.setLocalDescription(offer);
      
      socketIo?.emit("call:signal", {
        peerId: peerId,
        roomId,
        offer,
      });

      console.log(`üì§ Sent restart offer for peer ${peerId}`);

    } catch (error) {
      console.error(`‚ùå Error during reconnection attempt for ${peerId}:`, error);
      
      // N·∫øu restart ICE th·∫•t b·∫°i, th·ª≠ t·∫°o peer connection m·ªõi
      if (currentAttempts === maxAttempts - 1) {
        console.log(`üîÑ Last attempt: recreating peer connection for ${peerId}`);
        await recreatePeerConnection(peerId, roomId);
      }
    }
  };

  // Function ƒë·ªÉ t·∫°o l·∫°i peer connection ho√†n to√†n m·ªõi
  const recreatePeerConnection = async (peerId: string, roomId: string) => {
    try {
      console.log(`üèóÔ∏è Recreating peer connection for ${peerId}`);
      
      // ƒê√≥ng connection c≈©
      const oldPc = peers.current.get(peerId);
      if (oldPc) {
        oldPc.close();
        peers.current.delete(peerId);
      }

      // T·∫°o connection m·ªõi
      if (localStream) {
        const newPc = createPeerConnection(roomId, peerId, localStream);
        
        // T·∫°o offer m·ªõi
        const offer = await newPc.createOffer();
        await newPc.setLocalDescription(offer);
        
        socketIo?.emit("call:signal", {
          peerId: peerId,
          roomId,
          offer,
        });

        console.log(`‚úÖ Successfully recreated peer connection for ${peerId}`);
      }
    } catch (error) {
      console.error(`‚ùå Error recreating peer connection for ${peerId}:`, error);
    }
  };

  // Function ƒë·ªÉ cleanup peer
  const cleanupPeer = (peerId: string) => {
    // Clear timers
    const timer = reconnectTimers.current.get(peerId);
    if (timer) {
      clearTimeout(timer);
      reconnectTimers.current.delete(peerId);
    }
    
    // Clear reconnect attempts
    reconnectAttempts.current.delete(peerId);
    
    // Remove peer connection
    peers.current.delete(peerId);
  };

  // Cleanup call
  const hangUp = () => {
    // Clear t·∫•t c·∫£ timers
    reconnectTimers.current.forEach((timer) => {
      clearTimeout(timer);
    });
    reconnectTimers.current.clear();
    
    // Clear reconnect attempts
    reconnectAttempts.current.clear();
    
    // 1. D·ª´ng t·∫•t c·∫£ tracks trong localStream
    if (localStream) {
      localStream.getTracks().forEach((track) => {
        track.stop();
      });
    }
    
    // 2. D·ª´ng t·∫•t c·∫£ tracks trong remoteStream (n·∫øu c√≥)
    if (remoteStream) {
      remoteStream.getTracks().forEach((track) => {
        track.stop();
      });
    }
    
    // 3. ƒê√≥ng t·∫•t c·∫£ peer connections v√† cleanup
    peers.current.forEach((pc, peerId) => {
      cleanupPeer(peerId);
      
      // D·ª´ng t·∫•t c·∫£ senders
      pc.getSenders().forEach(sender => {
        if (sender.track) {
          sender.track.stop();
        }
      });
      
      // D·ª´ng t·∫•t c·∫£ receivers
      pc.getReceivers().forEach(receiver => {
        if (receiver.track) {
          receiver.track.stop();
        }
      });
      
      pc.close();
    });
    
    // 4. Clear peer connections map
    peers.current.clear();
    
    // 5. Clear pending candidates
    pendingCandidates.clear();
    
    // 6. Reset state
    setLocalStream(null);
    setRemoteStream(null);
    
    // 7. Cleanup socket listeners
    if (socketIo) {
      socketIo.off("client:signal");
    }
    
    // 8. Stop InCallManager
    try {
      InCallManager.stop();
    } catch (error) {
      console.error("‚ùå Error stopping InCallManager:", error);
    }
  };

  const toggleMute = () => {
    if (!localStream) {
      console.error("‚ùå No local stream to mute/unmute");
      return;
    }

    const audioTracks = localStream.getAudioTracks();
    if (audioTracks.length === 0) {
      console.error("‚ùå No audio tracks found");
      return;
    }

    const newMutedState = !isMuted;
    
    // T·∫Øt/b·∫≠t audio tracks
    audioTracks.forEach((track) => {
      track.enabled = !newMutedState;
    });
    
    // C·∫≠p nh·∫≠t state
    setIsMuted(newMutedState);
    
    // Th√¥ng b√°o cho t·∫•t c·∫£ peers v·ªÅ tr·∫°ng th√°i mute
    peers.current.forEach((pc, peerId) => {
      const sender = pc.getSenders().find(s => 
        s.track && s.track.kind === 'audio'
      );
      
      if (sender && sender.track) {
        sender.track.enabled = !newMutedState;
      }
    });
  };

  const toggleSpeaker = () => {
    try {
      const newSpeakerState = !isSpeakerOn;
      InCallManager.setSpeakerphoneOn(newSpeakerState);
      setIsSpeakerOn(newSpeakerState);
    } catch (error) {
      console.error("‚ùå Error toggling speaker:", error);
    }
  };

  const toggleVideo = () => {
    if (!localStream) {
      console.error("‚ùå No local stream to toggle video");
      return;
    }

    const videoTracks = localStream.getVideoTracks();
    if (videoTracks.length === 0) {
      console.error("‚ùå No video tracks found");
      return;
    }

    const newVideoState = !isVideoOff;
    
    videoTracks.forEach((track) => {
      track.enabled = !newVideoState;
    });
    
    // C·∫≠p nh·∫≠t state
    setIsVideoOff(newVideoState);
    
    // C·∫≠p nh·∫≠t cho t·∫•t c·∫£ peers
    peers.current.forEach((pc, peerId) => {
      const sender = pc.getSenders().find(s => 
        s.track && s.track.kind === 'video'
      );
      
      if (sender && sender.track) {
        sender.track.enabled = !newVideoState;
      }
    });
  };

  const switchCamera = () => {
    if (!localStream) {
      console.error("‚ùå No local stream to switch camera");
      return;
    }

    const videoTracks = localStream.getVideoTracks();
    if (videoTracks.length === 0) {
      console.error("‚ùå No video tracks found");
      return;
    }

    videoTracks.forEach((track: any) => {
      if (track._switchCamera) {
        track._switchCamera();
      }
    });
  };

  // L·∫Øng nghe t√≠n hi·ªáu 1 l·∫ßn duy nh·∫•t
  const listenCall = () => {
    if (!socketIo) {
      console.error("‚ùå Socket not available when trying to listen for call signals");
      return;
    }

    const handleSignal = async ({ metadata }: any) => {
      const { peerId, roomId, offer, answer, candidate } = metadata;
      
      // Ki·ªÉm tra c√°c gi√° tr·ªã b·∫Øt bu·ªôc
      if (!peerId || !roomId) {
        console.error("‚ùå Invalid signal: missing peerId or roomId");
        return;
      }
      // L·∫•y ho·∫∑c t·∫°o peer connection
      let pc = peers.current.get(peerId);
      if (!pc) {
        // ƒê·∫£m b·∫£o ƒë√£ kh·ªüi t·∫°o localStream tr∆∞·ªõc
        if (!localStream) {
          const stream = await initStream();
          if (!stream) {
            return; // Kh√¥ng ti·∫øp t·ª•c n·∫øu kh√¥ng th·ªÉ kh·ªüi t·∫°o stream
          }
          // T·∫°o peer connection v·ªõi stream m·ªõi l·∫•y ƒë∆∞·ª£c
          pc = createPeerConnection(roomId, peerId, stream);
        } else {
          // S·ª≠ d·ª•ng localStream ƒë√£ c√≥
          pc = createPeerConnection(roomId, peerId, localStream);
        }
      }

      if (offer) {
        try {
          await pc.setRemoteDescription(new RTCSessionDescription(offer));
          // X·ª≠ l√Ω c√°c ICE candidate ƒëang ch·ªù
          const pendingCands = pendingCandidates.get(peerId) || [];
          if (pendingCands.length > 0) {
            for (const candidate of pendingCands) {
              await pc.addIceCandidate(new RTCIceCandidate(candidate));
            }
            pendingCandidates.delete(peerId);
          }
          const answerDesc = await pc.createAnswer();
          await pc.setLocalDescription(answerDesc);
          socketIo.emit("call:signal", {
            peerId: peerId,
            roomId,
            answer: answerDesc,
          });
        } catch (error) {
          console.error("‚ùå Error processing offer:", error);
        }
      }

      if (answer) {
        try {
          await pc.setRemoteDescription(new RTCSessionDescription(answer));
          // X·ª≠ l√Ω c√°c ICE candidate ƒëang ch·ªù
          const pendingCands = pendingCandidates.get(peerId) || [];
          if (pendingCands.length > 0) {
            for (const candidate of pendingCands) {
              await pc.addIceCandidate(new RTCIceCandidate(candidate));
            }
            pendingCandidates.delete(peerId);
          }
        } catch (error) {
          console.error("‚ùå Error processing answer:", error);
        }
      }

      if (candidate) {
        try {
          if (pc.remoteDescription) {
            await pc.addIceCandidate(new RTCIceCandidate(candidate));
          } else {
            const queue = pendingCandidates.get(peerId) || [];
            queue.push(candidate);
            pendingCandidates.set(peerId, queue);
          }
        } catch (error) {
          console.error(`‚ùå Error processing ICE candidate for ${peerId}:`, error);
        }
      }
    };

    // X√≥a listener c≈© ƒë·ªÉ tr√°nh tr√πng l·∫∑p
    socketIo.off("client:signal");
    socketIo.on("client:signal", handleSignal);
  }

  return {
    localStream,
    remoteStream,
    isMuted,
    isSpeakerOn,
    isVideoOff,
    initStream,
    caller,
    callee,
    hangUp,
    toggleMute,
    toggleSpeaker,
    toggleVideo,
    switchCamera,
    listenCall,
    restartConnection: (peerId: string, roomId: string) => attemptReconnection(peerId, roomId),
  };
};
