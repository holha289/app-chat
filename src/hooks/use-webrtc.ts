import { useEffect, useRef, useState } from "react";
import { getSocket } from "@app/core/socketIo";
import InCallManager from "react-native-incall-manager";
import {
  mediaDevices,
  RTCPeerConnection,
  RTCIceCandidate,
  RTCSessionDescription,
  MediaStream,
} from "react-native-webrtc";
import { requestMediaPermissions } from "@app/core/permissions";

const pcConfig: RTCConfiguration = {
  iceServers: [
    { urls: ["stun:stun.l.google.com:19302"] },
    { urls: ["stun:stun1.l.google.com:19302"] },
    { urls: ["stun:stun2.l.google.com:19302"] },
    {
      urls: "turn:openrelay.metered.ca:443",
      username: "openrelayproject",
      credential: "openrelayproject",
    },
  ],
  iceCandidatePoolSize: 10,
  iceTransportPolicy: 'all',
  bundlePolicy: 'max-bundle',
  rtcpMuxPolicy: 'require',
};

export const useWebRTC = () => {
  const [localStream, setLocalStream] = useState<MediaStream | null>(null);
  const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);
  const [isScreenSharing, setIsScreenSharing] = useState(false);
  const [connectState, setConnectState] = useState('disconnected');
  const [isAudioEnabled, setIsAudioEnabled] = useState(true);
  const [isVideoEnabled, setIsVideoEnabled] = useState(true);
  const socketIo = getSocket();
  const localStreamRef = useRef<MediaStream | null>(null);
  const pendingOffer = useRef<RTCSessionDescription | null>(null);
  const pcRef = useRef<RTCPeerConnection | null>(null);
  const pendingCandidates = useRef<Map<string, RTCIceCandidate[]>>(new Map());

  const cleanUp = () => {
    if (pcRef.current) {
      pcRef.current.close();
      pcRef.current = null;
    }

    if (localStreamRef.current) {
      localStreamRef.current.getTracks().forEach(track => {
        track.stop(); // d·ª´ng c·∫£ mic + camera
      });
      localStreamRef.current = null;
    }

    if (remoteStream) {
      remoteStream.getTracks().forEach(track => {
        track.stop(); // ƒë·∫£m b·∫£o d·ª´ng audio c·ªßa ƒë·ªëi ph∆∞∆°ng
      });
    }

    setLocalStream(null);
    setRemoteStream(null);

    InCallManager.stop(); // d·ª´ng audio manager
    InCallManager.setForceSpeakerphoneOn(false); // reset loa
    InCallManager.setMicrophoneMute(true); // mute mic
    console.log("‚úÖ WebRTC cleanup completed");
  };

  useEffect(() => {
    socketIo?.on('connect', () => console.log("‚úÖ Socket.IO connected"));
    socketIo?.on('connect_error', (err) => console.error("‚ùå Socket.IO error:", err));
    InCallManager.setSpeakerphoneOn(true);
    return () => {
      cleanUp();
    };
  }, []);

  // Kh·ªüi t·∫°o local stream
  const initStream = async () => {
    if (localStreamRef.current) {
      console.log("‚úÖ Stream already initialized:", localStreamRef.current.getTracks());
      return localStreamRef.current;
    }
    try {
      const ok = await requestMediaPermissions();
      console.log("‚úÖ Permissions granted:", ok);
      if (!ok) {
        console.error("‚ùå User denied camera/mic permissions");
        return null;
      }

      const stream = await mediaDevices.getUserMedia({
        audio: true,
        video: isScreenSharing ? {
          facingMode: 'user',
          width: { ideal: 1280 },
          height: { ideal: 720 },
          frameRate: { ideal: 30 }
        } : false
      });
      console.log("‚úÖ Local stream tracks:", stream.getTracks());

      localStreamRef.current = stream;
      setLocalStream(stream);
      if (!isScreenSharing) {
        InCallManager.start({ media: "video", auto: true, ringback: "_DEFAULT_" });
        console.log("‚úÖ InCallManager started");
      } else {
        InCallManager.start({ media: "audio", auto: true, ringback: "_DEFAULT_" });
      }
      return stream;
    } catch (err) {
      console.error("‚ùå Error init media:", err);
      return null;
    }
  };

  // T·∫°o peer connection
  const createPeerConnection = (roomId: string, peerId: string, stream: MediaStream): RTCPeerConnection | null => {
    const streamToUse = stream;
    try {
      // T·∫°o RTCPeerConnection m·ªõi n·∫øu ch∆∞a c√≥
      const pc = new RTCPeerConnection(pcConfig);
      pcRef.current = pc;
      // Th√™m c√°c track t·ª´ local stream v√†o peer connection
      streamToUse.getTracks().forEach((track) => {
        console.log("‚úÖ Adding track:", track.kind, track.id);
        pc.addTrack(track, streamToUse);
      });

      // S·ª± ki·ªán ICE candidate m·ªõi
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          console.log("‚úÖ New ICE candidate:", event.candidate);
          socketIo?.emit("call:signal", {
            peerId: peerId,
            roomId,
            candidate: event.candidate,
          });
        } else {
          console.log("‚úÖ All ICE candidates sent");
        }
      };

      // S·ª± ki·ªán thay ƒë·ªïi tr·∫°ng th√°i k·∫øt n·ªëi ICE
      pc.oniceconnectionstatechange = () => {
        console.log(`ICE Connection State for ${peerId}:`, pc.iceConnectionState);
        switch (pc.iceConnectionState) {
          case 'connected':
          case 'completed':
            console.log(`‚úÖ WebRTC connected for peer ${peerId}`);
            setConnectState('connected');
            break;
          case 'disconnected':
            console.warn(`‚ö†Ô∏è WebRTC disconnected for peer ${peerId}`);
            setConnectState('disconnected');

            // Schedule reconnection attempt
            setTimeout(() => {
              if (pc.iceConnectionState === 'disconnected') {
                console.log(`üîÑ Attempting to reconnect for peer ${peerId}`);
                pc.restartIce();
              }
            }, 2000);
            break;
          case 'failed':
            console.error(`‚ùå WebRTC connection failed for peer ${peerId}`);
            setConnectState('failed');
            break;
          case 'closed':
            console.log(`WebRTC connection closed for peer ${peerId}`);
            setConnectState('closed');
            break;
        }
      };

      // S·ª± ki·ªán nh·∫≠n track t·ª´ remote
      pc.ontrack = (event) => {
        if (event.streams && event.streams[0]) {
          const stream = event.streams[0];
          console.log("‚úÖ Remote stream received, tracks:", stream.getTracks());
          setRemoteStream(stream as any);
        } else {
          console.error("‚ùå No remote stream received");
        }
      };
      return pc;
    } catch (err) {
      console.error("‚ùå Error creating peer connection:", err);
      return null;
    }
  };

  const handleCreateOffer = async (roomId: string, peerId: string) => {
    const stream = await initStream();
    if (!stream) {
      console.error("‚ùå Failed to initialize local stream for caller");
      return;
    }

    const pc = createPeerConnection(roomId, peerId, stream);
    if (!pc) {
      console.error("‚ùå Failed to create peer connection for caller");
      return;
    }

    try {
      const offer = await pc.createOffer({
        offerToReceiveVideo: true,
        offerToReceiveAudio: true,
        voiceActivityDetection: false,
      });
      await pc.setLocalDescription(offer);
      console.log("üì§ Sending offer:", offer);
      socketIo?.emit("call:signal", {
        peerId: peerId,
        roomId,
        offer,
      });
    } catch (err) {
      console.error("‚ùå Error creating offer:", err);
    }
  };

  const handleAcceptCall = async (roomId: string, peerId: string) => {
    // peerId l√† id ng∆∞·ªùi g·ªçi
    const stream = await initStream(); // S·ª≠ d·ª•ng h√†m initStream ƒë·ªÉ ƒë·∫£m b·∫£o stream ƒë∆∞·ª£c kh·ªüi t·∫°o ƒë√∫ng c√°ch
    if (!stream) {
      console.error("‚ùå Failed to initialize local stream for callee");
      return;
    }
    // T·∫°o v√† g·ª≠i c√¢u tr·∫£ l·ªùi
    const pc = createPeerConnection(roomId, peerId, stream);
    if (!pc) {
      console.error("‚ùå Failed to create peer connection for callee");
      return;
    }

    if (!pendingOffer.current) {
      console.error("‚ùå No pending offer to accept");
      return;
    }
    await pc.setRemoteDescription(pendingOffer.current);
    pendingOffer.current = null;
    // T·∫°o v√† g·ª≠i c√¢u tr·∫£ l·ªùi
    InCallManager.stopRingback();  // d·ª´ng √¢m b√°o
    try {
      const answerDesc = await pc.createAnswer();
      await pc.setLocalDescription(answerDesc);
      console.log("üì§ Sending answer:", answerDesc);
      socketIo?.emit("call:signal", {
        peerId: peerId,
        roomId,
        answer: answerDesc,
      });
      // flush ICE sau khi accept
      if (pendingCandidates.current.has(peerId)) {
        for (const cand of pendingCandidates.current.get(peerId)!) {
          await pc.addIceCandidate(new RTCIceCandidate(cand));
        }
        pendingCandidates.current.delete(peerId);
      }
    } catch (error) {
      console.error("‚ùå Error creating answer:", error);
    }
  };

  const listenCall = () => {
    const handleSignal = async ({ metadata }: any) => {
      if (!socketIo) {
        console.error("‚ùå No socket.io instance available");
        return;
      }
      console.log("üì° Received signal:", metadata);
      const { peerId, roomId, offer, answer, candidate } = metadata;

      if (!peerId || !roomId) {
        console.error("‚ùå Invalid signal: missing peerId or roomId");
        return;
      }

      try {
        if (offer) {
          // N·∫øu ng∆∞·ªùi g·ªçi ƒë·∫øn thi·∫øt l·∫≠p k·∫øt n·ªëi m·ªõi cho ng∆∞·ªùi nh·∫≠n
          pendingOffer.current = new RTCSessionDescription(offer);
          return;
        }

        if (answer) {
          InCallManager.stopRingback();  // d·ª´ng √¢m b√°o
          // Ng∆∞·ªùi g·ªçi x·ª≠ l√Ω c√¢u tr·∫£ l·ªùi t·ª´ ng∆∞·ªùi nh·∫≠n
          const pc = pcRef.current;
          if (!pc) {
            console.error("‚ùå No peer connection for answer from", peerId);
            return;
          }
          // Thi·∫øt l·∫≠p m√¥ t·∫£ t·ª´ xa
          await pc.setRemoteDescription(new RTCSessionDescription(answer));
        }
        // X·ª≠ l√Ω ICE candidate m·ªõi
        if (candidate) {
          const pc = pcRef.current;
          if (!pc || !pc.remoteDescription) {
            // l∆∞u t·∫°m n·∫øu ch∆∞a accept
            if (!pendingCandidates.current.has(peerId)) {
              pendingCandidates.current.set(peerId, []);
            }
            pendingCandidates.current.get(peerId)!.push(candidate);
            console.log("üì• Candidate queued:", candidate);
          } else {
            await pc.addIceCandidate(new RTCIceCandidate(candidate));
            console.log("‚úÖ Candidate added immediately");
          }
        }
      } catch (err) {
        console.error("‚ùå Error processing signal:", err);
      }
    };

    socketIo?.off("client:signal");
    socketIo?.on("client:signal", handleSignal);
  };

  const hangOut = () => {
    cleanUp();
    setConnectState('disconnected');
  };

  const toggleVideo = async (roomId: string) => {
    setIsVideoEnabled((prev) => !prev);
    if (localStreamRef.current) {
      const videoTrack = localStreamRef.current.getVideoTracks()[0];
      if (videoTrack) {
        videoTrack.enabled = !videoTrack.enabled;
        console.log(`‚úÖ Video track ${videoTrack.enabled ? 'enabled' : 'disabled'}`);
      }
    }
  };

  const toggleAudio = (roomId: string) => {
    setIsAudioEnabled((prev) => !prev);
    if (localStreamRef.current) {
      const audioTrack = localStreamRef.current.getAudioTracks()[0];
      if (audioTrack) {
        audioTrack.enabled = !audioTrack.enabled;
        console.log(`‚úÖ Audio track ${audioTrack.enabled ? 'enabled' : 'disabled'}`);
      }
    }
  };

  return {
    localStream,
    remoteStream,
    initStream,
    listenCall,
    setIsScreenSharing,
    handleCreateOffer,
    connectState,
    hangOut,
    toggleVideo,
    toggleAudio,
    isVideoEnabled,
    isAudioEnabled,
    handleAcceptCall
  };
};
